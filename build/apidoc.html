<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/ttezel/twit"

    >twit (v2.2.5)</a>
</h1>
<h4>Twitter API client for node (REST & Streaming)</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit">module twit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot">
            function <span class="apidocSignatureSpan">twit.</span>bot
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.file_uploader">
            function <span class="apidocSignatureSpan">twit.</span>file_uploader
            <span class="apidocSignatureSpan">(params, twit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.parser">
            function <span class="apidocSignatureSpan">twit.</span>parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection">
            function <span class="apidocSignatureSpan">twit.</span>streaming_api_connection
            <span class="apidocSignatureSpan">(reqOpts, twitOptions)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">twit.</span>bot.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">twit.</span>file_uploader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">twit.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">twit.</span>parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">twit.</span>streaming_api_connection.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.bot">module twit.bot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot.bot">
            function <span class="apidocSignatureSpan">twit.</span>bot
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.bot.prototype">module twit.bot.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot.prototype.favorite">
            function <span class="apidocSignatureSpan">twit.bot.prototype.</span>favorite
            <span class="apidocSignatureSpan">(params, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot.prototype.mingle">
            function <span class="apidocSignatureSpan">twit.bot.prototype.</span>mingle
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot.prototype.prune">
            function <span class="apidocSignatureSpan">twit.bot.prototype.</span>prune
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot.prototype.retweet">
            function <span class="apidocSignatureSpan">twit.bot.prototype.</span>retweet
            <span class="apidocSignatureSpan">(params, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot.prototype.searchFollow">
            function <span class="apidocSignatureSpan">twit.bot.prototype.</span>searchFollow
            <span class="apidocSignatureSpan">(params, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.bot.prototype.tweet">
            function <span class="apidocSignatureSpan">twit.bot.prototype.</span>tweet
            <span class="apidocSignatureSpan">(status, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.file_uploader">module twit.file_uploader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.file_uploader.file_uploader">
            function <span class="apidocSignatureSpan">twit.</span>file_uploader
            <span class="apidocSignatureSpan">(params, twit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.file_uploader.prototype">module twit.file_uploader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.file_uploader.prototype._appendMedia">
            function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_appendMedia
            <span class="apidocSignatureSpan">(media_id_string, chunk_part, segment_index, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.file_uploader.prototype._finalizeMedia">
            function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_finalizeMedia
            <span class="apidocSignatureSpan">(media_id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.file_uploader.prototype._initMedia">
            function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_initMedia
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.file_uploader.prototype._isUploadComplete">
            function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_isUploadComplete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.file_uploader.prototype.upload">
            function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>upload
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.helpers">module twit.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.helpers.attachBodyInfoToError">
            function <span class="apidocSignatureSpan">twit.helpers.</span>attachBodyInfoToError
            <span class="apidocSignatureSpan">(err, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.helpers.getBearerToken">
            function <span class="apidocSignatureSpan">twit.helpers.</span>getBearerToken
            <span class="apidocSignatureSpan">(consumer_key, consumer_secret, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.helpers.makeQueryString">
            function <span class="apidocSignatureSpan">twit.helpers.</span>makeQueryString
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.helpers.makeTwitError">
            function <span class="apidocSignatureSpan">twit.helpers.</span>makeTwitError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.helpers.moveParamsIntoPath">
            function <span class="apidocSignatureSpan">twit.helpers.</span>moveParamsIntoPath
            <span class="apidocSignatureSpan">(params, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.parser">module twit.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.parser.parser">
            function <span class="apidocSignatureSpan">twit.</span>parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.parser.super_">
            function <span class="apidocSignatureSpan">twit.parser.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.parser.prototype">module twit.parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.parser.prototype.parse">
            function <span class="apidocSignatureSpan">twit.parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.streaming_api_connection">module twit.streaming_api_connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.streaming_api_connection">
            function <span class="apidocSignatureSpan">twit.</span>streaming_api_connection
            <span class="apidocSignatureSpan">(reqOpts, twitOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.super_">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.twit.streaming_api_connection.prototype">module twit.streaming_api_connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._handleDisconnect">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_handleDisconnect
            <span class="apidocSignatureSpan">(twitterMsg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._onClose">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_onClose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._resetConnection">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_resetConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._resetRetryParams">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_resetRetryParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._resetStallAbortTimeout">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_resetStallAbortTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._scheduleReconnect">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_scheduleReconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._setOauthTimestamp">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_setOauthTimestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._setupParser">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_setupParser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._startPersistentConnection">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_startPersistentConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._stopStallAbortTimeout">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_stopStallAbortTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype._updateOauthTimestampOffsetFromResponse">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_updateOauthTimestampOffsetFromResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype.start">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.twit.streaming_api_connection.prototype.stop">
            function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit" id="apidoc.module.twit">module twit</a></h1>


    <h2>
        <a href="#apidoc.element.twit.bot" id="apidoc.element.twit.bot">
        function <span class="apidocSignatureSpan">twit.</span>bot
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bot = function (config) {
  this.twit = new Twit(config);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.file_uploader" id="apidoc.element.twit.file_uploader">
        function <span class="apidocSignatureSpan">twit.</span>file_uploader
        <span class="apidocSignatureSpan">(params, twit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_uploader = function (params, twit) {
  assert(params)
  assert(params.file_path, &#x27;Must specify `file_path` to upload a file. Got: &#x27; + params.file_path + &#x27;.&#x27;)
  var self = this;
  self._file_path = params.file_path;
  self._twit = twit;
  self._isUploading = false;
  self._isFileStreamEnded = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.parser" id="apidoc.element.twit.parser">
        function <span class="apidocSignatureSpan">twit.</span>parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parser = function ()  {
  this.message = &#x27;&#x27;

  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection" id="apidoc.element.twit.streaming_api_connection">
        function <span class="apidocSignatureSpan">twit.</span>streaming_api_connection
        <span class="apidocSignatureSpan">(reqOpts, twitOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streaming_api_connection = function (reqOpts, twitOptions) {
  this.reqOpts = reqOpts
  this.twitOptions = twitOptions
  this._twitter_time_minus_local_time_ms = 0
  EventEmitter.call(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.bot" id="apidoc.module.twit.bot">module twit.bot</a></h1>


    <h2>
        <a href="#apidoc.element.twit.bot.bot" id="apidoc.element.twit.bot.bot">
        function <span class="apidocSignatureSpan">twit.</span>bot
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bot = function (config) {
  this.twit = new Twit(config);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.bot.prototype" id="apidoc.module.twit.bot.prototype">module twit.bot.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.twit.bot.prototype.favorite" id="apidoc.element.twit.bot.prototype.favorite">
        function <span class="apidocSignatureSpan">twit.bot.prototype.</span>favorite
        <span class="apidocSignatureSpan">(params, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">favorite = function (params, callback) {
  var self = this;

  self.twit.get(&#x27;search/tweets&#x27;, params, function (err, reply) {
    if(err) return callback(err);

    var tweets = reply.statuses;
    var randomTweet = randIndex(tweets);
	if(typeof randomTweet != &#x27;undefined&#x27;)
		self.twit.post(&#x27;favorites/create&#x27;, { id: randomTweet.id_str }, callback);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.bot.prototype.mingle" id="apidoc.element.twit.bot.prototype.mingle">
        function <span class="apidocSignatureSpan">twit.bot.prototype.</span>mingle
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mingle = function (callback) {
  var self = this;

  this.twit.get(&#x27;followers/ids&#x27;, function(err, reply) {
      if(err) { return callback(err); }

      var followers = reply.ids
        , randFollower  = randIndex(followers);

      self.twit.get(&#x27;friends/ids&#x27;, { user_id: randFollower }, function(err, reply) {
          if(err) { return callback(err); }

          var friends = reply.ids
            , target  = randIndex(friends);

          self.twit.post(&#x27;friendships/create&#x27;, { id: target }, callback);
        })
    })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.bot.prototype.prune" id="apidoc.element.twit.bot.prototype.prune">
        function <span class="apidocSignatureSpan">twit.bot.prototype.</span>prune
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prune = function (callback) {
  var self = this;

  this.twit.get(&#x27;followers/ids&#x27;, function(err, reply) {
      if(err) return callback(err);

      var followers = reply.ids;

      self.twit.get(&#x27;friends/ids&#x27;, function(err, reply) {
          if(err) return callback(err);

          var friends = reply.ids
            , pruned = false;

          while(!pruned) {
            var target = randIndex(friends);

            if(!~followers.indexOf(target)) {
              pruned = true;
              self.twit.post(&#x27;friendships/destroy&#x27;, { id: target }, callback);
            }
          }
      });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.bot.prototype.retweet" id="apidoc.element.twit.bot.prototype.retweet">
        function <span class="apidocSignatureSpan">twit.bot.prototype.</span>retweet
        <span class="apidocSignatureSpan">(params, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retweet = function (params, callback) {
  var self = this;

  self.twit.get(&#x27;search/tweets&#x27;, params, function (err, reply) {
    if(err) return callback(err);

    var tweets = reply.statuses;
    var randomTweet = randIndex(tweets);
	if(typeof randomTweet != &#x27;undefined&#x27;)
		self.twit.post(&#x27;statuses/retweet/:id&#x27;, { id: randomTweet.id_str }, callback);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.bot.prototype.searchFollow" id="apidoc.element.twit.bot.prototype.searchFollow">
        function <span class="apidocSignatureSpan">twit.bot.prototype.</span>searchFollow
        <span class="apidocSignatureSpan">(params, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">searchFollow = function (params, callback) {
  var self = this;

  self.twit.get(&#x27;search/tweets&#x27;, params, function (err, reply) {
    if(err) return callback(err);

    var tweets = reply.statuses;
	var rTweet = randIndex(tweets)
	if(typeof rTweet != &#x27;undefined&#x27;)
	{
		var target = rTweet.user.id_str;

		self.twit.post(&#x27;friendships/create&#x27;, { id: target }, callback);
	}
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.bot.prototype.tweet" id="apidoc.element.twit.bot.prototype.tweet">
        function <span class="apidocSignatureSpan">twit.bot.prototype.</span>tweet
        <span class="apidocSignatureSpan">(status, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tweet = function (status, callback) {
  if(typeof status !== &#x27;string&#x27;) {
    return callback(new Error(&#x27;tweet must be of type String&#x27;));
  } else if(status.length &#x3e; 140) {
    return callback(new Error(&#x27;tweet is too long: &#x27; + status.length));
  }
  this.twit.post(&#x27;statuses/update&#x27;, { status: status }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.file_uploader" id="apidoc.module.twit.file_uploader">module twit.file_uploader</a></h1>


    <h2>
        <a href="#apidoc.element.twit.file_uploader.file_uploader" id="apidoc.element.twit.file_uploader.file_uploader">
        function <span class="apidocSignatureSpan">twit.</span>file_uploader
        <span class="apidocSignatureSpan">(params, twit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_uploader = function (params, twit) {
  assert(params)
  assert(params.file_path, &#x27;Must specify `file_path` to upload a file. Got: &#x27; + params.file_path + &#x27;.&#x27;)
  var self = this;
  self._file_path = params.file_path;
  self._twit = twit;
  self._isUploading = false;
  self._isFileStreamEnded = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.file_uploader.prototype" id="apidoc.module.twit.file_uploader.prototype">module twit.file_uploader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.twit.file_uploader.prototype._appendMedia" id="apidoc.element.twit.file_uploader.prototype._appendMedia">
        function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_appendMedia
        <span class="apidocSignatureSpan">(media_id_string, chunk_part, segment_index, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_appendMedia = function (media_id_string, chunk_part, segment_index, cb) {
  var self = this;
  self._twit.post(&#x27;media/upload&#x27;, {
    command: &#x27;APPEND&#x27;,
    media_id: media_id_string.toString(),
    segment_index: segment_index,
    media: chunk_part,
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      mediaFile.on(&#x27;data&#x27;, function (chunk) {
// Pause our file stream from emitting `data` events until the upload of this chunk completes.
// Any data that becomes available will remain in the internal buffer.
mediaFile.pause();
self._isUploading = true;

self.<span class="apidocCodeKeywordSpan">_appendMedia</span>(mediaTmpId, chunk.toString(&#x27;base64&#x27;), chunkNumber, function
 (err, bodyObj, resp) {
  self._isUploading = false;
  if (err) {
    cb(err);
  } else {
    if (self._isUploadComplete()) {
      // We&#x27;ve hit the end of our stream; send FINALIZE command.
      self._finalizeMedia(mediaTmpId, cb);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.file_uploader.prototype._finalizeMedia" id="apidoc.element.twit.file_uploader.prototype._finalizeMedia">
        function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_finalizeMedia
        <span class="apidocSignatureSpan">(media_id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finalizeMedia = function (media_id, cb) {
  var self = this;
  self._twit.post(&#x27;media/upload&#x27;, {
    command: &#x27;FINALIZE&#x27;,
    media_id: media_id
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._appendMedia(mediaTmpId, chunk.toString(&#x27;base64&#x27;), chunkNumber, function (err, bodyObj, resp) {
  self._isUploading = false;
  if (err) {
    cb(err);
  } else {
    if (self._isUploadComplete()) {
      // We&#x27;ve hit the end of our stream; send FINALIZE command.
      self.<span class="apidocCodeKeywordSpan">_finalizeMedia</span>(mediaTmpId, cb);
    } else {
      // Tell our file stream to start emitting `data` events again.
      chunkNumber++;
      mediaFile.resume();
    }
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.file_uploader.prototype._initMedia" id="apidoc.element.twit.file_uploader.prototype._initMedia">
        function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_initMedia
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initMedia = function (cb) {
  var self = this;
  var mediaType = mime.lookup(self._file_path);
  var mediaFileSizeBytes = fs.statSync(self._file_path).size;

  // Check the file size - it should not go over 15MB for video.
  // See https://dev.twitter.com/rest/reference/post/media/upload-chunked
  if (mediaFileSizeBytes &#x3c; MAX_FILE_SIZE_BYTES) {
    self._twit.post(&#x27;media/upload&#x27;, {
      &#x27;command&#x27;: &#x27;INIT&#x27;,
      &#x27;media_type&#x27;: mediaType,
      &#x27;total_bytes&#x27;: mediaFileSizeBytes
    }, cb);
  } else {
    var errMsg = util.format(&#x27;This file is too large. Max size is %dB. Got: %dB.&#x27;, MAX_FILE_SIZE_BYTES, mediaFileSizeBytes);
    cb(new Error(errMsg));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param  {Function} cb function (err, data, resp)
 */
FileUploader.prototype.upload = function (cb) {
var self = this;

// Send INIT command with file info and get back a media_id_string we can use to APPEND chunks to it.
self.<span class="apidocCodeKeywordSpan">_initMedia</span>(function (err, bodyObj, resp) {
  if (err) {
    cb(err);
    return;
  } else {
    var mediaTmpId = bodyObj.media_id_string;
    var chunkNumber = 0;
    var mediaFile = fs.createReadStream(self._file_path, { highWatermark: MAX_FILE_CHUNK_BYTES });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.file_uploader.prototype._isUploadComplete" id="apidoc.element.twit.file_uploader.prototype._isUploadComplete">
        function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>_isUploadComplete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isUploadComplete = function () {
  return !this._isUploading &#x26;&#x26; this._isFileStreamEnded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._isUploading = true;

self._appendMedia(mediaTmpId, chunk.toString(&#x27;base64&#x27;), chunkNumber, function (err, bodyObj, resp) {
  self._isUploading = false;
  if (err) {
    cb(err);
  } else {
    if (self.<span class="apidocCodeKeywordSpan">_isUploadComplete</span>()) {
      // We&#x27;ve hit the end of our stream; send FINALIZE command.
      self._finalizeMedia(mediaTmpId, cb);
    } else {
      // Tell our file stream to start emitting `data` events again.
      chunkNumber++;
      mediaFile.resume();
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.file_uploader.prototype.upload" id="apidoc.element.twit.file_uploader.prototype.upload">
        function <span class="apidocSignatureSpan">twit.file_uploader.prototype.</span>upload
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upload = function (cb) {
  var self = this;

  // Send INIT command with file info and get back a media_id_string we can use to APPEND chunks to it.
  self._initMedia(function (err, bodyObj, resp) {
    if (err) {
      cb(err);
      return;
    } else {
      var mediaTmpId = bodyObj.media_id_string;
      var chunkNumber = 0;
      var mediaFile = fs.createReadStream(self._file_path, { highWatermark: MAX_FILE_CHUNK_BYTES });

      mediaFile.on(&#x27;data&#x27;, function (chunk) {
        // Pause our file stream from emitting `data` events until the upload of this chunk completes.
        // Any data that becomes available will remain in the internal buffer.
        mediaFile.pause();
        self._isUploading = true;

        self._appendMedia(mediaTmpId, chunk.toString(&#x27;base64&#x27;), chunkNumber, function (err, bodyObj, resp) {
          self._isUploading = false;
          if (err) {
            cb(err);
          } else {
            if (self._isUploadComplete()) {
              // We&#x27;ve hit the end of our stream; send FINALIZE command.
              self._finalizeMedia(mediaTmpId, cb);
            } else {
              // Tell our file stream to start emitting `data` events again.
              chunkNumber++;
              mediaFile.resume();
            }
          }
        });
      });

      mediaFile.on(&#x27;end&#x27;, function () {
        // Mark our file streaming complete, and if done, send FINALIZE command.
        self._isFileStreamEnded = true;
        if (self._isUploadComplete()) {
          self._finalizeMedia(mediaTmpId, cb);
        }
      });
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var MAX_FILE_SIZE_BYTES = 15 * 1024 * 1024;
var MAX_FILE_CHUNK_BYTES = 5 * 1024 * 1024;

/**
 * FileUploader class used to upload a file to twitter via the /media/upload (chunked) API.
 * Usage:
 *   var fu = new FileUploader({ file_path: &#x27;/foo/bar/baz.mp4&#x27; }, twit);
 *   fu.<span class="apidocCodeKeywordSpan">upload</span>(function (err, bodyObj, resp) {
 *     console.log(err, bodyObj);
 *   })
 *
 * @param  {Object}         params  Object of the form { file_path: String }.
 * @param  {Twit(object)}   twit    Twit instance.
 */
var FileUploader = function (params, twit) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.helpers" id="apidoc.module.twit.helpers">module twit.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.twit.helpers.attachBodyInfoToError" id="apidoc.element.twit.helpers.attachBodyInfoToError">
        function <span class="apidocSignatureSpan">twit.helpers.</span>attachBodyInfoToError
        <span class="apidocSignatureSpan">(err, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachBodyInfoToError = function (err, body) {
  err.twitterReply = body;
  if (!body) {
    return
  }
  if (body.error) {
    // the body itself is an error object
    err.message = body.error
    err.allErrors = err.allErrors.concat([body])
  } else if (body.errors &#x26;&#x26; body.errors.length) {
    // body contains multiple error objects
    err.message = body.errors[0].message;
    err.code = body.errors[0].code;
    err.allErrors = err.allErrors.concat(body.errors)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;
  },
  body: &#x27;grant_type=client_credentials&#x27;,
  json: true,
}, function (err, res, body) {
  if (err) {
    var error = exports.makeTwitError(err.toString());
    exports.<span class="apidocCodeKeywordSpan">attachBodyInfoToError</span>(error, body);
    return cb(error, body, res);
  }

  if ( !body ) {
    var error = exports.makeTwitError(&#x27;Not valid reply from Twitter upon obtaining bearer token&#x27;);
    exports.attachBodyInfoToError(error, body);
    return cb(error, body, res);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.helpers.getBearerToken" id="apidoc.element.twit.helpers.getBearerToken">
        function <span class="apidocSignatureSpan">twit.helpers.</span>getBearerToken
        <span class="apidocSignatureSpan">(consumer_key, consumer_secret, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBearerToken = function (consumer_key, consumer_secret, cb) {
  // use OAuth 2 for app-only auth (Twitter requires this)
  // get a bearer token using our app&#x27;s credentials
  var b64Credentials = new Buffer(consumer_key + &#x27;:&#x27; + consumer_secret).toString(&#x27;base64&#x27;);
  request.post({
    url: endpoints.API_HOST + &#x27;/oauth2/token&#x27;,
    headers: {
      &#x27;Authorization&#x27;: &#x27;Basic &#x27; + b64Credentials,
      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;
    },
    body: &#x27;grant_type=client_credentials&#x27;,
    json: true,
  }, function (err, res, body) {
    if (err) {
      var error = exports.makeTwitError(err.toString());
      exports.attachBodyInfoToError(error, body);
      return cb(error, body, res);
    }

    if ( !body ) {
      var error = exports.makeTwitError(&#x27;Not valid reply from Twitter upon obtaining bearer token&#x27;);
      exports.attachBodyInfoToError(error, body);
      return cb(error, body, res);
    }

    if (body.token_type !== &#x27;bearer&#x27;) {
      var error = exports.makeTwitError(&#x27;Unexpected reply from Twitter upon obtaining bearer token&#x27;);
      exports.attachBodyInfoToError(error, body);
      return cb(error, body, res);
    }

    return cb(err, body.access_token);
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.helpers.makeQueryString" id="apidoc.element.twit.helpers.makeQueryString">
        function <span class="apidocSignatureSpan">twit.helpers.</span>makeQueryString
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeQueryString = function (obj) {
  var qs = querystring.stringify(obj)
  qs = qs.replace(/\!/g, &#x22;%21&#x22;)
         .replace(/\&#x27;/g, &#x22;%27&#x22;)
         .replace(/\(/g, &#x22;%28&#x22;)
         .replace(/\)/g, &#x22;%29&#x22;)
         .replace(/\*/g, &#x22;%2A&#x22;);
  return qs
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.helpers.makeTwitError" id="apidoc.element.twit.helpers.makeTwitError">
        function <span class="apidocSignatureSpan">twit.helpers.</span>makeTwitError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeTwitError = function (message) {
  var err = new Error()
  if (message) {
    err.message = message
  }
  err.code = null
  err.allErrors = []
  err.twitterReply = null
  return err
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;Authorization&#x27;: &#x27;Basic &#x27; + b64Credentials,
    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;
  },
  body: &#x27;grant_type=client_credentials&#x27;,
  json: true,
}, function (err, res, body) {
  if (err) {
    var error = exports.<span class="apidocCodeKeywordSpan">makeTwitError</span>(err.toString());
    exports.attachBodyInfoToError(error, body);
    return cb(error, body, res);
  }

  if ( !body ) {
    var error = exports.makeTwitError(&#x27;Not valid reply from Twitter upon obtaining bearer token&#x27;);
    exports.attachBodyInfoToError(error, body);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.helpers.moveParamsIntoPath" id="apidoc.element.twit.helpers.moveParamsIntoPath">
        function <span class="apidocSignatureSpan">twit.helpers.</span>moveParamsIntoPath
        <span class="apidocSignatureSpan">(params, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveParamsIntoPath = function (params, path) {
  var rgxParam = /\/:(\w+)/g
  var missingParamErr = null

  path = path.replace(rgxParam, function (hit) {
    var paramName = hit.slice(2)
    var suppliedVal = params[paramName]
    if (!suppliedVal) {
      throw new Error(&#x27;Twit: Params object is missing a required parameter for this request: `&#x27;+paramName+&#x27;`&#x27;)
    }
    var retVal = &#x27;/&#x27; + suppliedVal
    delete params[paramName]
    return retVal
  })
  return path
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.parser" id="apidoc.module.twit.parser">module twit.parser</a></h1>


    <h2>
        <a href="#apidoc.element.twit.parser.parser" id="apidoc.element.twit.parser.parser">
        function <span class="apidocSignatureSpan">twit.</span>parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parser = function ()  {
  this.message = &#x27;&#x27;

  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.parser.super_" id="apidoc.element.twit.parser.super_">
        function <span class="apidocSignatureSpan">twit.parser.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.parser.prototype" id="apidoc.module.twit.parser.prototype">module twit.parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.twit.parser.prototype.parse" id="apidoc.element.twit.parser.prototype.parse">
        function <span class="apidocSignatureSpan">twit.parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (chunk) {
  this.message += chunk;
  chunk = this.message;

  var size = chunk.length
    , start = 0
    , offset = 0
    , curr
    , next;

  while (offset &#x3c; size) {
    curr = chunk[offset];
    next = chunk[offset + 1];

    if (curr === &#x27;\r&#x27; &#x26;&#x26; next === &#x27;\n&#x27;) {
      var piece = chunk.slice(start, offset);
      start = offset += 2;

      if (!piece.length) { continue; } //empty object

      if (piece === &#x27;Exceeded connection limit for user&#x27;) {
        this.emit(&#x27;connection-limit-exceeded&#x27;,
                  new Error(&#x27;Twitter says: &#x27; + piece + &#x27;. Only instantiate one stream per set of credentials.&#x27;));
        continue;
      }

      try {
        var msg = JSON.parse(piece)
      } catch (err) {
        this.emit(&#x27;error&#x27;, new Error(&#x27;Error parsing twitter reply: `&#x27;+piece+&#x27;`, error message `&#x27;+err+&#x27;`&#x27;));
      } finally {
        if (msg)
          this.emit(&#x27;element&#x27;, msg)

        continue
      }
    }
    offset++;
  }

  this.message = chunk.slice(start, size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (piece === &#x27;Exceeded connection limit for user&#x27;) {
this.emit(&#x27;connection-limit-exceeded&#x27;,
          new Error(&#x27;Twitter says: &#x27; + piece + &#x27;. Only instantiate one stream per set of credentials.&#x27;));
continue;
      }

      try {
var msg = JSON.<span class="apidocCodeKeywordSpan">parse</span>(piece)
      } catch (err) {
this.emit(&#x27;error&#x27;, new Error(&#x27;Error parsing twitter reply: `&#x27;+piece+&#x27;`, error message `&#x27;+err+&#x27
;`&#x27;));
      } finally {
if (msg)
  this.emit(&#x27;element&#x27;, msg)

continue
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.streaming_api_connection" id="apidoc.module.twit.streaming_api_connection">module twit.streaming_api_connection</a></h1>


    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.streaming_api_connection" id="apidoc.element.twit.streaming_api_connection.streaming_api_connection">
        function <span class="apidocSignatureSpan">twit.</span>streaming_api_connection
        <span class="apidocSignatureSpan">(reqOpts, twitOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streaming_api_connection = function (reqOpts, twitOptions) {
  this.reqOpts = reqOpts
  this.twitOptions = twitOptions
  this._twitter_time_minus_local_time_ms = 0
  EventEmitter.call(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.super_" id="apidoc.element.twit.streaming_api_connection.super_">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.twit.streaming_api_connection.prototype" id="apidoc.module.twit.streaming_api_connection.prototype">module twit.streaming_api_connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._handleDisconnect" id="apidoc.element.twit.streaming_api_connection.prototype._handleDisconnect">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_handleDisconnect
        <span class="apidocSignatureSpan">(twitterMsg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleDisconnect = function (twitterMsg) {
  this.emit(&#x27;disconnect&#x27;, twitterMsg);
  this.stop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // handle twitter objects as they come in - emit the generic `message` event
  // along with the specific event corresponding to the message
  self.parser.on(&#x27;element&#x27;, function (msg) {
self.emit(&#x27;message&#x27;, msg)

if      (msg.delete)          { self.emit(&#x27;delete&#x27;, msg) }
else if (msg.disconnect)      { self.<span class="apidocCodeKeywordSpan">_handleDisconnect</span>(msg) }
else if (msg.limit)           { self.emit(&#x27;limit&#x27;, msg) }
else if (msg.scrub_geo)       { self.emit(&#x27;scrub_geo&#x27;, msg) }
else if (msg.warning)         { self.emit(&#x27;warning&#x27;, msg) }
else if (msg.status_withheld) { self.emit(&#x27;status_withheld&#x27;, msg) }
else if (msg.user_withheld)   { self.emit(&#x27;user_withheld&#x27;, msg) }
else if (msg.friends || msg.friends_str) { self.emit(&#x27;friends&#x27;, msg) }
else if (msg.direct_message)  { self.emit(&#x27;direct_message&#x27;, msg) }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._onClose" id="apidoc.element.twit.streaming_api_connection.prototype._onClose">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_onClose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onClose = function () {
  var self = this;
  self._stopStallAbortTimeout();
  if (self._scheduledReconnect) {
    // if we already have a reconnect scheduled, don&#x27;t schedule another one.
    // this race condition can happen if the http.ClientRequest and http.IncomingMessage both emit `close`
    return
  }

  self._scheduleReconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._resetConnection" id="apidoc.element.twit.streaming_api_connection.prototype._resetConnection">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_resetConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resetConnection = function () {
  if (this.request) {
    // clear our reference to the `request` instance
    this.request.removeAllListeners();
    this.request.destroy();
  }

  if (this.response) {
    // clear our reference to the http.IncomingMessage instance
    this.response.removeAllListeners();
    this.response.destroy();
  }

  if (this.parser) {
    this.parser.removeAllListeners()
  }

  // ensure a scheduled reconnect does not occur (if one was scheduled)
  // this can happen if we get a close event before .stop() is called
  clearTimeout(this._scheduledReconnect)
  delete this._scheduledReconnect

  // clear our stall abort timeout
  this._stopStallAbortTimeout()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._connectInterval = 0
// flag indicating whether we used a 0-delay reconnect
this._usedFirstReconnect = false
}

StreamingAPIConnection.prototype._startPersistentConnection = function () {
var self = this;
self.<span class="apidocCodeKeywordSpan">_resetConnection</span>();
self._setupParser();
self._resetStallAbortTimeout();
self._setOauthTimestamp();
self.request = request.post(this.reqOpts);
self.emit(&#x27;connect&#x27;, self.request);
self.request.on(&#x27;response&#x27;, function (response) {
  self._updateOauthTimestampOffsetFromResponse(response)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._resetRetryParams" id="apidoc.element.twit.streaming_api_connection.prototype._resetRetryParams">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_resetRetryParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resetRetryParams = function () {
  // delay for next reconnection attempt
  this._connectInterval = 0
  // flag indicating whether we used a 0-delay reconnect
  this._usedFirstReconnect = false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Kick off the http request, and persist the connection
*
*/
StreamingAPIConnection.prototype.start = function () {
 this.<span class="apidocCodeKeywordSpan">_resetRetryParams</span>();
 this._startPersistentConnection();
 return this;
}

/**
* Abort the http request, stop scheduled reconnect (if one was scheduled) and clear state
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._resetStallAbortTimeout" id="apidoc.element.twit.streaming_api_connection.prototype._resetStallAbortTimeout">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_resetStallAbortTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resetStallAbortTimeout = function () {
  var self = this;
  // stop the previous stall abort timer
  self._stopStallAbortTimeout();
  //start a new 90s timeout to trigger a close &#x26; reconnect if no data received
  self._stallAbortTimeout = setTimeout(function () {
    self._scheduleReconnect()
  }, 90000);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._usedFirstReconnect = false
}

StreamingAPIConnection.prototype._startPersistentConnection = function () {
var self = this;
self._resetConnection();
self._setupParser();
self.<span class="apidocCodeKeywordSpan">_resetStallAbortTimeout</span>();
self._setOauthTimestamp();
self.request = request.post(this.reqOpts);
self.emit(&#x27;connect&#x27;, self.request);
self.request.on(&#x27;response&#x27;, function (response) {
  self._updateOauthTimestampOffsetFromResponse(response)
  // reset our reconnection attempt flag so next attempt goes through with 0 delay
  // if we get a transport-level error
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._scheduleReconnect" id="apidoc.element.twit.streaming_api_connection.prototype._scheduleReconnect">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_scheduleReconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_scheduleReconnect = function () {
  var self = this;
  if (self.response &#x26;&#x26; self.response.statusCode === 420) {
    // we are being rate limited
    // start with a 1 minute wait and double each attempt
    if (!self._connectInterval) {
      self._connectInterval = 60000;
    } else {
      self._connectInterval *= 2;
    }
  } else if (self.response &#x26;&#x26; String(self.response.statusCode).charAt(0) === &#x27;5&#x27;) {
    // twitter 5xx errors
    // start with a 5s wait, double each attempt up to 320s
    if (!self._connectInterval) {
      self._connectInterval = 5000;
    } else if (self._connectInterval &#x3c; 320000) {
      self._connectInterval *= 2;
    } else {
      self._connectInterval = 320000;
    }
  } else {
    // we did not get an HTTP response from our last connection attempt.
    // DNS/TCP error, or a stall in the stream (and stall timer closed the connection)
    if (!self._usedFirstReconnect) {
      // first reconnection attempt on a valid connection should occur immediately
      self._connectInterval = 0;
      self._usedFirstReconnect = true;
    } else if (self._connectInterval &#x3c; 16000) {
      // linearly increase delay by 250ms up to 16s
      self._connectInterval += 250;
    } else {
      // cap out reconnect interval at 16s
      self._connectInterval = 16000;
    }
  }

  // schedule the reconnect
  self._scheduledReconnect = setTimeout(function () {
    self._startPersistentConnection();
  }, self._connectInterval);
  self.emit(&#x27;reconnect&#x27;, self.request, self.response, self._connectInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var twitErr = helpers.makeTwitError(errMsg);
  twitErr.statusCode = self.response.statusCode;
  helpers.attachBodyInfoToError(twitErr, compressedBody);
  self.emit(&#x27;parser-error&#x27;, twitErr);
});
    } else if (self.response.statusCode === 420) {
// close the connection forcibly so a reconnect is scheduled by `self.onClose()`
self.<span class="apidocCodeKeywordSpan">_scheduleReconnect</span>();
    } else {
// We got an OK status code - the response should be valid.
// Read the body from the response and return to the user.
var gunzip = zlib.createGunzip();
self.response.pipe(gunzip);

//pass all response data to parser
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._setOauthTimestamp" id="apidoc.element.twit.streaming_api_connection.prototype._setOauthTimestamp">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_setOauthTimestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setOauthTimestamp = function () {
  var self = this;
  if (self.reqOpts.oauth) {
    var oauth_ts = Date.now() + self._twitter_time_minus_local_time_ms;
    self.reqOpts.oauth.timestamp = Math.floor(oauth_ts/1000).toString();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

StreamingAPIConnection.prototype._startPersistentConnection = function () {
var self = this;
self._resetConnection();
self._setupParser();
self._resetStallAbortTimeout();
self.<span class="apidocCodeKeywordSpan">_setOauthTimestamp</span>();
self.request = request.post(this.reqOpts);
self.emit(&#x27;connect&#x27;, self.request);
self.request.on(&#x27;response&#x27;, function (response) {
  self._updateOauthTimestampOffsetFromResponse(response)
  // reset our reconnection attempt flag so next attempt goes through with 0 delay
  // if we get a transport-level error
  self._usedFirstReconnect = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._setupParser" id="apidoc.element.twit.streaming_api_connection.prototype._setupParser">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_setupParser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setupParser = function () {
  var self = this
  self.parser = new Parser()

  // handle twitter objects as they come in - emit the generic `message` event
  // along with the specific event corresponding to the message
  self.parser.on(&#x27;element&#x27;, function (msg) {
    self.emit(&#x27;message&#x27;, msg)

    if      (msg.delete)          { self.emit(&#x27;delete&#x27;, msg) }
    else if (msg.disconnect)      { self._handleDisconnect(msg) }
    else if (msg.limit)           { self.emit(&#x27;limit&#x27;, msg) }
    else if (msg.scrub_geo)       { self.emit(&#x27;scrub_geo&#x27;, msg) }
    else if (msg.warning)         { self.emit(&#x27;warning&#x27;, msg) }
    else if (msg.status_withheld) { self.emit(&#x27;status_withheld&#x27;, msg) }
    else if (msg.user_withheld)   { self.emit(&#x27;user_withheld&#x27;, msg) }
    else if (msg.friends || msg.friends_str) { self.emit(&#x27;friends&#x27;, msg) }
    else if (msg.direct_message)  { self.emit(&#x27;direct_message&#x27;, msg) }
    else if (msg.event)           {
      self.emit(&#x27;user_event&#x27;, msg)
      // reference: https://dev.twitter.com/docs/streaming-apis/messages#User_stream_messages
      var ev = msg.event

      if      (ev === &#x27;blocked&#x27;)                { self.emit(&#x27;blocked&#x27;, msg) }
      else if (ev === &#x27;unblocked&#x27;)              { self.emit(&#x27;unblocked&#x27;, msg) }
      else if (ev === &#x27;favorite&#x27;)               { self.emit(&#x27;favorite&#x27;, msg) }
      else if (ev === &#x27;unfavorite&#x27;)             { self.emit(&#x27;unfavorite&#x27;, msg) }
      else if (ev === &#x27;follow&#x27;)                 { self.emit(&#x27;follow&#x27;, msg) }
      else if (ev === &#x27;unfollow&#x27;)               { self.emit(&#x27;unfollow&#x27;, msg) }
      else if (ev === &#x27;mute&#x27;)                   { self.emit(&#x27;mute&#x27;, msg) }
      else if (ev === &#x27;unmute&#x27;)                 { self.emit(&#x27;unmute&#x27;, msg) }
      else if (ev === &#x27;user_update&#x27;)            { self.emit(&#x27;user_update&#x27;, msg) }
      else if (ev === &#x27;list_created&#x27;)           { self.emit(&#x27;list_created&#x27;, msg) }
      else if (ev === &#x27;list_destroyed&#x27;)         { self.emit(&#x27;list_destroyed&#x27;, msg) }
      else if (ev === &#x27;list_updated&#x27;)           { self.emit(&#x27;list_updated&#x27;, msg) }
      else if (ev === &#x27;list_member_added&#x27;)      { self.emit(&#x27;list_member_added&#x27;, msg) }
      else if (ev === &#x27;list_member_removed&#x27;)    { self.emit(&#x27;list_member_removed&#x27;, msg) }
      else if (ev === &#x27;list_user_subscribed&#x27;)   { self.emit(&#x27;list_user_subscribed&#x27;, msg) }
      else if (ev === &#x27;list_user_unsubscribed&#x27;) { self.emit(&#x27;list_user_unsubscribed&#x27;, msg) }
      else if (ev === &#x27;quoted_tweet&#x27;)           { self.emit(&#x27;quoted_tweet&#x27;, msg) }
      else if (ev === &#x27;favorited_retweet&#x27;)      { self.emit(&#x27;favorited_retweet&#x27;, msg) }
      else if (ev === &#x27;retweeted_retweet&#x27;)      { self.emit(&#x27;retweeted_retweet&#x27;, msg) }
      else                                      { self.emit(&#x27;unknown_user_event&#x27;, msg) }
    } else                                      { self.emit(&#x27;tweet&#x27;, msg) }
  })

  self.parser.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;parser-error&#x27;, err)
  });
  self.parser.on(&#x27;connection-limit-exceeded&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// flag indicating whether we used a 0-delay reconnect
this._usedFirstReconnect = false
}

StreamingAPIConnection.prototype._startPersistentConnection = function () {
var self = this;
self._resetConnection();
self.<span class="apidocCodeKeywordSpan">_setupParser</span>();
self._resetStallAbortTimeout();
self._setOauthTimestamp();
self.request = request.post(this.reqOpts);
self.emit(&#x27;connect&#x27;, self.request);
self.request.on(&#x27;response&#x27;, function (response) {
  self._updateOauthTimestampOffsetFromResponse(response)
  // reset our reconnection attempt flag so next attempt goes through with 0 delay
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._startPersistentConnection" id="apidoc.element.twit.streaming_api_connection.prototype._startPersistentConnection">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_startPersistentConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startPersistentConnection = function () {
  var self = this;
  self._resetConnection();
  self._setupParser();
  self._resetStallAbortTimeout();
  self._setOauthTimestamp();
  self.request = request.post(this.reqOpts);
  self.emit(&#x27;connect&#x27;, self.request);
  self.request.on(&#x27;response&#x27;, function (response) {
    self._updateOauthTimestampOffsetFromResponse(response)
    // reset our reconnection attempt flag so next attempt goes through with 0 delay
    // if we get a transport-level error
    self._usedFirstReconnect = false;
    // start a stall abort timeout handle
    self._resetStallAbortTimeout();
    self.response = response
    if (STATUS_CODES_TO_ABORT_ON.indexOf(self.response.statusCode) !== -1) {
      // We got a status code telling us we should abort the connection.
      // Read the body from the response and return an error to the user.
      var body = &#x27;&#x27;;
      var compressedBody = &#x27;&#x27;;

      self.response.on(&#x27;data&#x27;, function (chunk) {
        compressedBody += chunk.toString(&#x27;utf8&#x27;);
      })

      var gunzip = zlib.createGunzip();
      self.response.pipe(gunzip);
      gunzip.on(&#x27;data&#x27;, function (chunk) {
        body += chunk.toString(&#x27;utf8&#x27;)
      })

      gunzip.on(&#x27;end&#x27;, function () {
        try {
          body = JSON.parse(body)
        } catch (jsonDecodeError) {
          // Twitter may send an HTML body
          // if non-JSON text was returned, we&#x27;ll just attach it to the error as-is
        }
        // surface the error to the user
        var error = helpers.makeTwitError(&#x27;Bad Twitter streaming request: &#x27; + self.response.statusCode)
        error.statusCode = response ? response.statusCode: null;
        helpers.attachBodyInfoToError(error, body)
        self.emit(&#x27;error&#x27;, error);
        // stop the stream explicitly so we don&#x27;t reconnect
        self.stop()
        body = null;
      });
      gunzip.on(&#x27;error&#x27;, function (err) {
        // If Twitter sends us back an uncompressed HTTP response, gzip will error out.
        // Handle this by emitting an error with the uncompressed response body.
        var errMsg = &#x27;Gzip error: &#x27; + err.message;
        var twitErr = helpers.makeTwitError(errMsg);
        twitErr.statusCode = self.response.statusCode;
        helpers.attachBodyInfoToError(twitErr, compressedBody);
        self.emit(&#x27;parser-error&#x27;, twitErr);
      });
    } else if (self.response.statusCode === 420) {
      // close the connection forcibly so a reconnect is scheduled by `self.onClose()`
      self._scheduleReconnect();
    } else {
      // We got an OK status code - the response should be valid.
      // Read the body from the response and return to the user.
      var gunzip = zlib.createGunzip();
      self.response.pipe(gunzip);

      //pass all response data to parser
      gunzip.on(&#x27;data&#x27;, function (chunk) {
        self._connectInterval = 0
        // stop stall timer, and start a new one
        self._resetStallAbortTimeout();
        self.parser.parse(chunk.toString(&#x27;utf8&#x27;));
      });

      gunzip.on(&#x27;close&#x27;, self._onClose.bind(self))
      gunzip.on(&#x27;error&#x27;, function (err) {
        self.emit(&#x27;error&#x27;, err);
      })
      self.response.on(&#x27;error&#x27;, function (err) {
        // expose response errors on twit instance
        self.emit(&#x27;error&#x27;, err);
      })

      // connected without an error response from Twitter, emit `connected` event
      // this must be emitted after all its event handlers are bound
      // so the reference to `self.response` is not interfered-with by the user until it is emitted
      self.emit(&#x27;connected&#x27;, self.response);
    }
  });
  self.request.on(&#x27;close&#x27;, self._onClose.bind(self));
  self.request.on(&#x27;error&#x27;, function (err) { self._scheduleReconnect.bind(self) });
  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Kick off the http request, and persist the connection
*
*/
StreamingAPIConnection.prototype.start = function () {
 this._resetRetryParams();
 this.<span class="apidocCodeKeywordSpan">_startPersistentConnection</span>();
 return this;
}

/**
* Abort the http request, stop scheduled reconnect (if one was scheduled) and clear state
*
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._stopStallAbortTimeout" id="apidoc.element.twit.streaming_api_connection.prototype._stopStallAbortTimeout">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_stopStallAbortTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stopStallAbortTimeout = function () {
  clearTimeout(this._stallAbortTimeout);
  // mark the timer as `null` so it is clear via introspection that the timeout is not scheduled
  delete this._stallAbortTimeout;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// ensure a scheduled reconnect does not occur (if one was scheduled)
// this can happen if we get a close event before .stop() is called
clearTimeout(this._scheduledReconnect)
delete this._scheduledReconnect

// clear our stall abort timeout
this.<span class="apidocCodeKeywordSpan">_stopStallAbortTimeout</span>()
}

/**
 * Resets the parameters used in determining the next reconnect time
 */
StreamingAPIConnection.prototype._resetRetryParams = function () {
// delay for next reconnection attempt
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype._updateOauthTimestampOffsetFromResponse" id="apidoc.element.twit.streaming_api_connection.prototype._updateOauthTimestampOffsetFromResponse">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>_updateOauthTimestampOffsetFromResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateOauthTimestampOffsetFromResponse = function (resp) {
  if (resp &#x26;&#x26; resp.headers &#x26;&#x26; resp.headers.date &#x26;&#x26;
      new Date(resp.headers.date).toString() !== &#x27;Invalid Date&#x27;
  ) {
    var twitterTimeMs = new Date(resp.headers.date).getTime()
    this._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._resetConnection();
self._setupParser();
self._resetStallAbortTimeout();
self._setOauthTimestamp();
self.request = request.post(this.reqOpts);
self.emit(&#x27;connect&#x27;, self.request);
self.request.on(&#x27;response&#x27;, function (response) {
  self.<span class="apidocCodeKeywordSpan">_updateOauthTimestampOffsetFromResponse</span>(response)
  // reset our reconnection attempt flag so next attempt goes through with 0 delay
  // if we get a transport-level error
  self._usedFirstReconnect = false;
  // start a stall abort timeout handle
  self._resetStallAbortTimeout();
  self.response = response
  if (STATUS_CODES_TO_ABORT_ON.indexOf(self.response.statusCode) !== -1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype.start" id="apidoc.element.twit.streaming_api_connection.prototype.start">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  this._resetRetryParams();
  this._startPersistentConnection();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
```

##stream.stop()

Call this function on the stream to stop streaming (closes the connection with Twitter).

##stream.<span class="apidocCodeKeywordSpan">start</span>()

Call this function to restart the stream after you called `.stop()` on it.
Note: there is no need to call `.start()` to begin streaming. `Twit.stream` calls `.start()` for you.

-------

#What do I have access to?
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.twit.streaming_api_connection.prototype.stop" id="apidoc.element.twit.streaming_api_connection.prototype.stop">
        function <span class="apidocSignatureSpan">twit.streaming_api_connection.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function () {
  // clear connection variables and timeout handles
  this._resetConnection();
  this._resetRetryParams();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  statusCode:   &#x27;...&#x27;,  // statusCode from Twitter
  code:         &#x27;...&#x27;,  // error code from Twitter
  twitterReply: &#x27;...&#x27;,  // raw response data from Twitter
  allErrors:    &#x27;...&#x27;   // array of errors returned from Twitter
}
```

##stream.<span class="apidocCodeKeywordSpan">stop</span>()

Call this function on the stream to stop streaming (closes the connection with Twitter).

##stream.start()

Call this function to restart the stream after you called `.stop()` on it.
Note: there is no need to call `.start()` to begin streaming. `Twit.stream` calls `.start()` for you.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
